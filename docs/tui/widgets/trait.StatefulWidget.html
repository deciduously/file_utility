<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A `StatefulWidget` is a widget that can take advantage of some local state to remember things between two draw calls."><meta name="keywords" content="rust, rustlang, rust-lang, StatefulWidget"><title>StatefulWidget in tui::widgets - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../tui/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Trait StatefulWidget</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#associated-types">Associated Types</a><div class="sidebar-links"><a href="#associatedtype.State">State</a></div><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.render">render</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class="location"><a href="../index.html">tui</a>::<wbr><a href="index.html">widgets</a></p><div id="sidebar-vars" data-name="StatefulWidget" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../index.html">tui</a>::<wbr><a href="index.html">widgets</a>::<wbr><a class="trait" href="">StatefulWidget</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/tui/widgets/mod.rs.html#182-185" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust trait">pub trait StatefulWidget {
    type <a href="#associatedtype.State" class="type">State</a>;
    fn <a href="#tymethod.render" class="fnname">render</a>(self, area: <a class="struct" href="../layout/struct.Rect.html" title="struct tui::layout::Rect">Rect</a>, buf: &amp;mut <a class="struct" href="../buffer/struct.Buffer.html" title="struct tui::buffer::Buffer">Buffer</a>, state: &amp;mut Self::<a class="type" href="trait.StatefulWidget.html#associatedtype.State" title="type tui::widgets::StatefulWidget::State">State</a>);
}</pre></div><div class="docblock"><p>A <code>StatefulWidget</code> is a widget that can take advantage of some local state to remember things
between two draw calls.</p>
<p>Most widgets can be drawn directly based on the input parameters. However, some features may
require some kind of associated state to be implemented.</p>
<p>For example, the <a href="struct.List.html" title="List"><code>List</code></a> widget can highlight the item currently selected. This can be
translated in an offset, which is the number of elements to skip in order to have the selected
item within the viewport currently allocated to this widget. The widget can therefore only
provide the following behavior: whenever the selected item is out of the viewport scroll to a
predefined position (making the selected item the last viewable item or the one in the middle
for example). Nonetheless, if the widget has access to the last computed offset then it can
implement a natural scrolling experience where the last offset is reused until the selected
item is out of the viewport.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="comment">// Let&#39;s say we have some events to display.</span>
<span class="kw">struct</span> <span class="ident">Events</span> {
    <span class="comment">// `items` is the state managed by your application.</span>
    <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    <span class="comment">// `state` is the state that can be modified by the UI. It stores the index of the selected</span>
    <span class="comment">// item as well as the offset computed during the previous draw call (used to implement</span>
    <span class="comment">// natural scrolling).</span>
    <span class="ident">state</span>: <span class="ident">ListState</span>
}

<span class="kw">impl</span> <span class="ident">Events</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Events</span> {
        <span class="ident">Events</span> {
            <span class="ident">items</span>,
            <span class="ident">state</span>: <span class="ident">ListState::default</span>(),
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_items</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>) {
        <span class="self">self</span>.<span class="ident">items</span> <span class="op">=</span> <span class="ident">items</span>;
        <span class="comment">// We reset the state as the associated items have changed. This effectively reset</span>
        <span class="comment">// the selection as well as the stored offset.</span>
        <span class="self">self</span>.<span class="ident">state</span> <span class="op">=</span> <span class="ident">ListState::default</span>();
    }

    <span class="comment">// Select the next item. This will not be reflected until the widget is drawn in the</span>
    <span class="comment">// `Terminal::draw` callback using `Frame::render_stateful_widget`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="kw">match</span> <span class="self">self</span>.<span class="ident">state</span>.<span class="ident">selected</span>() {
            <span class="prelude-val">Some</span>(<span class="ident">i</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="ident">i</span> <span class="op">&gt;</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">items</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span> {
                    <span class="number">0</span>
                } <span class="kw">else</span> {
                    <span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>
                }
            }
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>,
        };
        <span class="self">self</span>.<span class="ident">state</span>.<span class="ident">select</span>(<span class="prelude-val">Some</span>(<span class="ident">i</span>));
    }

    <span class="comment">// Select the previous item. This will not be reflected until the widget is drawn in the</span>
    <span class="comment">// `Terminal::draw` callback using `Frame::render_stateful_widget`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">previous</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="kw">match</span> <span class="self">self</span>.<span class="ident">state</span>.<span class="ident">selected</span>() {
            <span class="prelude-val">Some</span>(<span class="ident">i</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="ident">i</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
                    <span class="self">self</span>.<span class="ident">items</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span>
                } <span class="kw">else</span> {
                    <span class="ident">i</span> <span class="op">-</span> <span class="number">1</span>
                }
            }
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>,
        };
        <span class="self">self</span>.<span class="ident">state</span>.<span class="ident">select</span>(<span class="prelude-val">Some</span>(<span class="ident">i</span>));
    }

    <span class="comment">// Unselect the currently selected item if any. The implementation of `ListState` makes</span>
    <span class="comment">// sure that the stored offset is also reset.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">unselect</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">state</span>.<span class="ident">select</span>(<span class="prelude-val">None</span>);
    }
}

<span class="kw">let</span> <span class="ident">stdout</span> <span class="op">=</span> <span class="ident">io::stdout</span>();
<span class="kw">let</span> <span class="ident">backend</span> <span class="op">=</span> <span class="ident">TermionBackend::new</span>(<span class="ident">stdout</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">terminal</span> <span class="op">=</span> <span class="ident">Terminal::new</span>(<span class="ident">backend</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">Events::new</span>(<span class="macro">vec!</span>[
    <span class="ident">String::from</span>(<span class="string">&quot;Item 1&quot;</span>),
    <span class="ident">String::from</span>(<span class="string">&quot;Item 2&quot;</span>)
]);

<span class="kw">loop</span> {
    <span class="ident">terminal</span>.<span class="ident">draw</span>(<span class="op">|</span><span class="ident">f</span><span class="op">|</span> {
        <span class="comment">// The items managed by the application are transformed to something</span>
        <span class="comment">// that is understood by tui.</span>
        <span class="kw">let</span> <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ListItem</span><span class="op">&gt;</span><span class="op">=</span> <span class="ident">events</span>.<span class="ident">items</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="ident">ListItem::new</span>(<span class="ident">i</span>.<span class="ident">as_ref</span>())).<span class="ident">collect</span>();
        <span class="comment">// The `List` widget is then built with those items.</span>
        <span class="kw">let</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">List::new</span>(<span class="ident">items</span>);
        <span class="comment">// Finally the widget is rendered using the associated state. `events.state` is</span>
        <span class="comment">// effectively the only thing that we will &quot;remember&quot; from this draw call.</span>
        <span class="ident">f</span>.<span class="ident">render_stateful_widget</span>(<span class="ident">list</span>, <span class="ident">f</span>.<span class="ident">size</span>(), <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">events</span>.<span class="ident">state</span>);
    });

    <span class="comment">// In response to some input events or an external http request or whatever:</span>
    <span class="ident">events</span>.<span class="ident">next</span>();
}</pre></div>
</div><h2 id="associated-types" class="small-section-header">Associated Types<a href="#associated-types" class="anchor"></a></h2><div class="methods"><h3 id="associatedtype.State" class="method"><code>type <a href="#associatedtype.State" class="type">State</a></code><a class="srclink" href="../../src/tui/widgets/mod.rs.html#183" title="goto source code">[src]</a></h3></div><span class="loading-content">Loading content...</span><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><h3 id="tymethod.render" class="method"><code>fn <a href="#tymethod.render" class="fnname">render</a>(self, area: <a class="struct" href="../layout/struct.Rect.html" title="struct tui::layout::Rect">Rect</a>, buf: &amp;mut <a class="struct" href="../buffer/struct.Buffer.html" title="struct tui::buffer::Buffer">Buffer</a>, state: &amp;mut Self::<a class="type" href="trait.StatefulWidget.html#associatedtype.State" title="type tui::widgets::StatefulWidget::State">State</a>)</code><a class="srclink" href="../../src/tui/widgets/mod.rs.html#184" title="goto source code">[src]</a></h3></div><span class="loading-content">Loading content...</span><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-StatefulWidget" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="trait.StatefulWidget.html" title="trait tui::widgets::StatefulWidget">StatefulWidget</a> for <a class="struct" href="struct.List.html" title="struct tui::widgets::List">List</a>&lt;'a&gt;</code><a href="#impl-StatefulWidget" class="anchor"></a><a class="srclink" href="../../src/tui/widgets/list.rs.html#134-242" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.State-1" class="type trait-impl"><code>type <a href="#associatedtype.State" class="type">State</a> = <a class="struct" href="struct.ListState.html" title="struct tui::widgets::ListState">ListState</a></code><a href="#associatedtype.State-1" class="anchor"></a></h4><h4 id="method.render" class="method hidden trait-impl"><code>fn <a href="#tymethod.render" class="fnname">render</a>(self, area: <a class="struct" href="../layout/struct.Rect.html" title="struct tui::layout::Rect">Rect</a>, buf: &amp;mut <a class="struct" href="../buffer/struct.Buffer.html" title="struct tui::buffer::Buffer">Buffer</a>, state: &amp;mut Self::<a class="type" href="trait.StatefulWidget.html#associatedtype.State" title="type tui::widgets::StatefulWidget::State">State</a>)</code><a href="#method.render" class="anchor"></a><a class="srclink" href="../../src/tui/widgets/list.rs.html#137-241" title="goto source code">[src]</a></h4></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-StatefulWidget-1" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="trait.StatefulWidget.html" title="trait tui::widgets::StatefulWidget">StatefulWidget</a> for <a class="struct" href="struct.Table.html" title="struct tui::widgets::Table">Table</a>&lt;'a&gt;</code><a href="#impl-StatefulWidget-1" class="anchor"></a><a class="srclink" href="../../src/tui/widgets/table.rs.html#397-510" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.State-2" class="type trait-impl"><code>type <a href="#associatedtype.State" class="type">State</a> = <a class="struct" href="struct.TableState.html" title="struct tui::widgets::TableState">TableState</a></code><a href="#associatedtype.State-2" class="anchor"></a></h4><h4 id="method.render-1" class="method hidden trait-impl"><code>fn <a href="#tymethod.render" class="fnname">render</a>(self, area: <a class="struct" href="../layout/struct.Rect.html" title="struct tui::layout::Rect">Rect</a>, buf: &amp;mut <a class="struct" href="../buffer/struct.Buffer.html" title="struct tui::buffer::Buffer">Buffer</a>, state: &amp;mut Self::<a class="type" href="trait.StatefulWidget.html#associatedtype.State" title="type tui::widgets::StatefulWidget::State">State</a>)</code><a href="#method.render-1" class="anchor"></a><a class="srclink" href="../../src/tui/widgets/table.rs.html#400-509" title="goto source code">[src]</a></h4></div></details></div><span class="loading-content">Loading content...</span><script type="text/javascript" src="../../implementors/tui/widgets/trait.StatefulWidget.js" async></script></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="tui" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script></body></html>